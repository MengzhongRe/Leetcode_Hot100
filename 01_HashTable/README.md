# 哈希表经典题型总结（两数之和/字母异位词分组/最长连续序列）
哈希表（Hash Table）是算法题中优化「查找效率」的核心工具，其核心优势是**增删改查操作的平均时间复杂度为 O(1)**。本文总结三道哈希表高频题，从解题思路、关键代码、复杂度分析三个维度拆解，帮你掌握哈希表的核心应用场景。

---

## 一、LeetCode 1. 两数之和
### 题目描述
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回它们的数组下标。
- 要求：每种输入只会对应一个答案，且同一个元素不能使用两遍。

### 解题思路
核心思路：**空间换时间**，用哈希表存储已遍历元素的「值-下标」映射，避免暴力解法的双重循环。
1. 初始化空哈希表（字典），用于记录「数字 → 下标」；
2. 遍历数组，对每个元素 `num`：
   - 计算补数 `target - num`，判断补数是否在哈希表中；
   - 若存在，直接返回「补数下标」和「当前元素下标」；
   - 若不存在，将当前元素和下标存入哈希表；
3. 遍历结束未找到则返回空（题目保证有解）。

### 关键代码
```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        # 哈希表：key=数字，value=下标
        num_map = {}
        for idx, num in enumerate(nums):
            complement = target - num
            # 补数存在则返回结果
            if complement in num_map:
                return [num_map[complement], idx]
            # 补数不存在则存入当前数字和下标
            num_map[num] = idx
        return []  # 题目保证有解，此处仅为鲁棒性
```

### 复杂度分析
| 维度         | 结果                | 说明                                                                 |
|--------------|---------------------|----------------------------------------------------------------------|
| 时间复杂度   | $O(n)$              | 遍历数组一次，每个元素的哈希表操作（查/存）均为 $O(1)$               |
| 空间复杂度   | $O(n)$              | 最坏情况下哈希表存储 $n-1$ 个元素（最后一个元素找到解）               |
| 最优时间     | $O(1)$              | 前两个元素即满足条件，遍历1次就返回                                  |

---

## 二、LeetCode 49. 字母异位词分组
### 题目描述
给你一个字符串数组，请你将 **字母异位词** 组合在一起。字母异位词是指由相同字母重排列形成的字符串（比如 `eat` 和 `tea`）。
- 要求：返回结果的顺序任意，每个组内的字符串顺序任意。

### 解题思路
核心思路：**为异位词生成唯一特征标识（哈希Key）**，将特征相同的字符串归为一组。
#### 方案1：字符计数法（最优时间复杂度）
1. 利用「小写字母仅26个」的特性，用长度为26的数组统计每个字符出现次数；
2. 将计数数组转为元组（数组不可哈希，元组可哈希）作为哈希Key；
3. 用哈希表存储「Key → 异位词列表」，最终返回哈希表的值列表。

#### 方案2：排序字符串法（代码更简洁）
1. 对每个字符串排序，异位词排序后结果相同（如 `eat` → `aet`，`tea` → `aet`）；
2. 以排序后的字符串为哈希Key，分组存储原字符串。

### 关键代码
#### 方案1：字符计数法（时间最优）
```python
from typing import List
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        # 默认字典：key=字符计数元组，value=异位词列表
        group_map = defaultdict(list)
        for s in strs:
            # 初始化26位计数数组（对应a-z）
            counts = [0] * 26
            for ch in s:
                # 字符映射为数组下标：a→0，b→1...z→25
                counts[ord(ch) - ord('a')] += 1
            # 数组转元组作为哈希Key（数组不可哈希）
            key = tuple(counts)
            group_map[key].append(s)
        # 转换为列表返回（dict_values → list）
        return list(group_map.values())
```

#### 方案2：排序字符串法（简洁易写）
```python
from typing import List
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        group_map = defaultdict(list)
        for s in strs:
            # 排序后的字符串作为唯一Key
            key = ''.join(sorted(s))
            group_map[key].append(s)
        return list(group_map.values())
```

### 复杂度分析
#### 方案1：字符计数法
| 维度         | 结果                | 说明                                                                 |
|--------------|---------------------|----------------------------------------------------------------------|
| 时间复杂度   | $O(nk)$             | $n$=字符串数量，$k$=单个字符串最大长度；计数数组操作为 $O(k)$，转元组为 $O(1)$（固定26位） |
| 空间复杂度   | $O(nk)$             | 哈希表存储所有字符串，总字符数为 $nk$；计数数组仅占 $O(1)$ 空间       |

#### 方案2：排序字符串法
| 维度         | 结果                | 说明                                                                 |
|--------------|---------------------|----------------------------------------------------------------------|
| 时间复杂度   | $O(nk logk)$        | 排序单个字符串的时间为 $O(k logk)$，遍历 $n$ 个字符串总时间为 $O(nk logk)$ |
| 空间复杂度   | $O(nk)$             | 与字符计数法一致，哈希表存储所有字符串                               |

---

## 三、LeetCode 128. 最长连续序列
### 题目描述
给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
- 要求：算法的时间复杂度为 $O(n)$。

### 解题思路
核心思路：**哈希集合优化查找 + 仅从序列起点统计**，避免重复计算。
1. 将数组转为哈希集合（去重 + $O(1)$ 查找）；
2. 遍历集合中的每个数：
   - 若 `num - 1` 不在集合中，说明是「连续序列的起点」；
   - 从起点开始，依次查找 `num+1、num+2...`，统计序列长度；
3. 记录所有序列的最大长度。

### 关键代码
```python
from typing import List

class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        # 转哈希集合：去重 + O(1) 查找
        num_set = set(nums)
        max_len = 0
        
        for num in num_set:
            # 仅从序列起点开始统计（避免重复计算）
            if num - 1 not in num_set:
                current_num = num
                current_len = 1
                # 查找连续的下一个数
                while current_num + 1 in num_set:
                    current_num += 1
                    current_len += 1
                # 更新最大长度
                max_len = max(max_len, current_len)
        
        return max_len
```

### 复杂度分析
| 维度         | 结果                | 说明                                                                 |
|--------------|---------------------|----------------------------------------------------------------------|
| 时间复杂度   | $O(n)$              | 每个元素仅被访问一次（要么跳过，要么在while循环中统计），哈希集合查找为 $O(1)$ |
| 空间复杂度   | $O(n)$              | 哈希集合存储去重后的所有元素，最多 $n$ 个                            |

## 四、哈希表题型核心总结
| 题型                | 核心应用场景                | 关键技巧                                                                 |
|---------------------|-----------------------------|--------------------------------------------------------------------------|
| 两数之和            | 快速查找「补数」            | 哈希表存储「值-下标」映射，避免双重循环                                  |
| 字母异位词分组      | 生成「唯一特征Key」         | 字符计数/排序字符串生成Key，defaultdict简化分组逻辑                      |
| 最长连续序列        | 快速判断「元素是否存在」    | 哈希集合去重+O(1)查找，仅从序列起点统计避免重复计算                      |

### 哈希表通用优化思路
1. **空间换时间**：用哈希表存储中间结果，将查找时间从 $O(n)$ 优化为 $O(1)$；
2. **去重**：利用哈希表Key的唯一性，快速剔除重复元素；
3. **特征映射**：将复杂特征（如字符频次、排序字符串）转为可哈希的Key，实现分组/匹配。

### 注意事项
1. 哈希表的「最坏时间复杂度」：极端哈希冲突下，查找/插入可能退化为 $O(n)$，但工程中默认按平均 $O(1)$ 分析；
2. 可哈希类型：Python中字典/集合的Key必须是可哈希类型（如int、str、tuple），列表/数组需转为元组后才能作为Key；
3. defaultdict的使用：避免手动判断Key是否存在，简化「分组/计数」类场景的代码。