# 42. 接雨水 题目总结（MD格式）

# 一、题目核心

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例1：输入 [0,1,0,2,1,0,1,3,2,1,2,1] → 输出 6

示例2：输入 [4,2,0,3,2,5] → 输出 9

# 二、核心解题原理（接水本质）

对于任意位置 `i`，能接住的雨水量由「短板效应」决定，核心公式为：

`water[i] = max(0, min(左最高高度L[i], 右最高高度R[i]) - 当前柱子高度height[i])`

说明：

- L[i]：位置i左侧（包含i）所有柱子的最大高度，即 `L[i] = max(height[0..i])`

- R[i]：位置i右侧（包含i）所有柱子的最大高度，即 `R[i] = max(height[i..n-1])`

- 若 `min(L[i], R[i]) ≤ height[i]`，则该位置无法接水，接水量为0

总接水量 = 所有位置 `water[i]` 的总和。

# 三、最优解法：双指针法（面试高频）

## 3.1 算法思路（通俗版）

无需提前计算所有位置的L[i]和R[i]，通过两个指针动态判断「当前可确定接水量的位置」，逐步遍历计算，实现时间和空间最优。

1. 初始化：左指针left=0（数组左端），右指针right=n-1（数组右端）；

2. 维护两个变量：left_max（left左侧及当前的最大高度）、right_max（right右侧及当前的最大高度）；

3. 遍历判断：每次移动「高度较小的一侧指针」，因为该侧指针位置的接水量可被确定（由短板决定）；

4. 累加计算：每移动一次指针，计算当前指针位置的接水量，累加到总结果中；

5. 终止条件：left ≥ right 时，所有位置计算完毕。

## 3.2 完整代码（Python）

```python
def trap(height):
    # 边界处理：空数组直接返回0
    if not height:
        return 0
    
    left = 0  # 左指针
    right = len(height) - 1  # 右指针
    left_max = 0  # 左指针侧最大高度
    right_max = 0  # 右指针侧最大高度
    res = 0  # 总接水量
    
    while left < right:
        # 更新当前侧的最大高度
        left_max = max(left_max, height[left])
        right_max = max(right_max, height[right])
        
        # 左侧为短板，计算left位置接水量，左指针右移
        if left_max < right_max:
            res += left_max - height[left]
            left += 1
        # 右侧为短板（含left_max == right_max），计算right位置接水量，右指针左移
        else:
            res += right_max - height[right]
            right -= 1
    
    return res

# 测试用例
if __name__ == "__main__":
    test1 = [0,1,0,2,1,0,1,3,2,1,2,1]
    test2 = [4,2,0,3,2,5]
    print(trap(test1))  # 输出：6
    print(trap(test2))  # 输出：9
```

## 3.3 关键细节：left_max == right_max 的处理

当 `left_max == right_max` 时，代码归入`else` 分支，计算并移动右指针，原因如下：

1. 此时，left位置的短板是left_max（右侧有≥right_max=left_max的柱子挡水），right位置的短板是right_max（左侧有≥left_max=right_max的柱子挡水）；

2. 两个位置的接水量均可确定，先计算哪一个、移动哪一个指针，均不影响最终结果；

3. 代码选择移动右指针，仅为实现约定，无特殊逻辑，若改为移动左指针，结果同样正确。

# 四、算法正确性证明（逻辑/数学层面）

采用「数学归纳法」证明，核心目标：双指针遍历过程中，每一步计算的接水量均为真实值，最终总和正确。

## 4.1 归纳假设

假设当指针移动到 `left = k`、`right = m`（k < m）时：

- left_max = max(height[0..k])，right_max = max(height[m..n-1])；

- 0..k-1 和 m+1..n-1 位置的接水量已全部计算正确。

## 4.2 归纳推导（分3种情况）

### 情况1：left_max < right_max

对于left=k位置：

- 真实L[k] = left_max（left_max是0..k的最大值）；

- 真实R[k] ≥ right_max（right是k右侧指针，right_max是right..n-1的最大值）；

- 因此 min(L[k], R[k]) = left_max，接水量 = left_max - height[k]（与代码计算一致）；

- 移动left指针（left++），进入下一轮，符合归纳假设。

### 情况2：left_max > right_max

与情况1对称：

- 对于right=m位置，真实R[m] = right_max，真实L[m] ≥ left_max；

- min(L[m], R[m]) = right_max，接水量 = right_max - height[m]（与代码计算一致）；

- 移动right指针（right--），进入下一轮，符合归纳假设。

### 情况3：left_max == right_max

此时left和right位置的接水量均可确定，代码选择计算right位置、移动right指针，计算结果正确，且移动后仍符合归纳假设。

## 4.3 终止条件验证

当left ≥ right时，所有位置（0..n-1）均已计算完毕，总接水量为所有位置接水量之和，与真实值一致，证明结束。

# 五、其他解法（了解即可）

|解法|核心思路|时间复杂度|空间复杂度|评价|
|---|---|---|---|---|
|暴力法|遍历每个位置，分别遍历左右找最大高度，计算接水量|O(n²)|O(1)|简单易想，但效率极低，不推荐面试使用|
|动态规划|用两个数组pre_max、suf_max，提前存储每个位置的左右最大高度，再遍历计算|O(n)|O(n)|效率高，但比双指针多占用空间，面试可作为备选思路|
|双指针法|动态判断短板，移动指针，实时计算接水量|O(n)|O(1)|最优解，面试高频考点，需重点掌握|
# 六、核心总结

1. 接雨水的核心是「短板效应」，所有解法均围绕核心公式展开；

2. 双指针法的关键的是「动态确定可计算位置」，避免冗余计算，实现时间和空间最优；

3. left_max == right_max 时，移动任意指针均可，不影响结果，代码无需单独处理；

4. 面试重点：掌握双指针法的代码和正确性逻辑，能清晰解释「为什么移动短板指针」。

这份总结涵盖了题目所有关键内容，符合MD格式规范。需要我帮你**提炼核心公式和双指针关键步骤**，生成可快速背诵的面试笔记吗？