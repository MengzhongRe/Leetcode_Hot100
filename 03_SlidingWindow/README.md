# LeetCode 438. 找到字符串中所有字母异位词 题解总结

## 一、题目描述
给定两个字符串 `s` 和 `p`，找到 `s` 中所有是 `p` 的字母异位词的子串，返回这些子串的起始索引。

- **字母异位词**：由相同字母以不同顺序排列而成的字符串（如 "abc" 和 "bac"）。
- **要求**：答案不考虑顺序，且时间复杂度尽可能低。

**示例 1**：
输入：`s = "cbaebabacd"`, `p = "abc"`
输出：`[0, 6]`
解释：`s` 中起始索引为 0 的子串是 "cba"，起始索引为 6 的子串是 "bac"，均为 "abc" 的字母异位词。

**示例 2**：
输入：`s = "abab"`, `p = "ab"`
输出：`[0, 1, 2]`
解释：`s` 中起始索引为 0、1、2 的子串分别是 "ab"、"ba"、"ab"，均为 "ab" 的字母异位词。

## 二、核心思路：滑动窗口 + 数组计数 + 差异值优化
### 1. 核心原理
判断两个字符串是否为字母异位词，本质是判断它们的**字符频次是否完全相同**。
- 固定窗口大小为 `len(p)`，在 `s` 上滑动，每次判断窗口内字符频次与 `p` 是否一致。
- 用**长度为 26 的数组**记录字符频次差值（窗口字符频次 +1，`p` 字符频次 -1），数组全 0 则为异位词。
- 用**差异值 `differ`** 记录频次不匹配的字符种类数，避免每次遍历 26 个字母，将时间复杂度优化至 O(n)。

### 2. 关键概念
- **`count` 数组**：长度 26，对应 `a-z`，记录窗口与 `p` 的字符频次差值。
- **`differ` 变量**：记录 `count` 中不为 0 的元素个数（即频次不匹配的字符种类数），`differ = 0` 时窗口为异位词。

## 三、算法步骤
1. **边界处理**：若 `len(s) < len(p)`，直接返回空列表。
2. **初始化窗口**：遍历 `p` 和 `s` 前 `len(p)` 个字符，更新 `count` 数组。
3. **计算初始差异值**：统计 `count` 中不为 0 的元素个数，得到 `differ`。
4. **滑动窗口遍历**：
   - 移除窗口左侧字符，更新 `count` 和 `differ`。
   - 添加窗口右侧新字符，更新 `count` 和 `differ`。
   - 若 `differ = 0`，记录当前窗口起始索引。
5. **返回结果**：所有异位词子串的起始索引列表。

## 四、完整代码实现
```python
from typing import List

class Solution(object):
    def findAnagrams(self, s: str, p: str) -> List[int]:
        s_len, p_len = len(s), len(p)
        # 边界：s 比 p 短，无异位词
        if s_len < p_len:
            return []
        
        count = [0] * 26  # 字符频次差值数组
        res = []          # 结果列表
        
        # 初始化第一个窗口：统计 s 前 p_len 字符与 p 的频次差
        for i in range(p_len):
            count[ord(s[i]) - ord('a')] += 1
            count[ord(p[i]) - ord('a')] -= 1
        
        # 计算初始差异值：频次不匹配的字符种类数
        differ = sum(1 for c in count if c != 0)
        
        # 检查第一个窗口是否为异位词
        if differ == 0:
            res.append(0)
        
        # 滑动窗口：遍历剩余位置
        for i in range(s_len - p_len):
            # 移除窗口左侧字符 s[i]
            left_idx = ord(s[i]) - ord('a')
            if count[left_idx] == 1:
                differ -= 1  # 从不匹配→匹配，差异数-1
            elif count[left_idx] == 0:
                differ += 1  # 从匹配→不匹配，差异数+1
            count[left_idx] -= 1
            
            # 添加窗口右侧新字符 s[i+p_len]
            right_idx = ord(s[i + p_len]) - ord('a')
            if count[right_idx] == -1:
                differ -= 1  # 从不匹配→匹配，差异数-1
            elif count[right_idx] == 0:
                differ += 1  # 从匹配→不匹配，差异数+1
            count[right_idx] += 1
            
            # 检查当前窗口是否为异位词
            if differ == 0:
                res.append(i + 1)
        
        return res
```

## 五、复杂度分析
### 1. 时间复杂度：O(n)
- `n` 为字符串 `s` 的长度。
- 初始化窗口遍历 `p`（O(m)，`m` 为 `p` 长度），滑动窗口遍历 `s` 剩余部分（O(n-m)），总遍历次数为 O(n)。
- 所有单次操作（字符转换、数组更新、差异值判断）均为 O(1)。

### 2. 空间复杂度：O(1)
- 仅使用固定大小的 `count` 数组（长度 26）和若干变量，与输入规模无关，属于常数空间。

## 六、关键优化点
1. **数组替代哈希表**：用长度 26 的数组记录字符频次，比哈希表更高效，空间固定。
2. **差异值 `differ`**：避免每次滑动窗口都遍历 26 个字母判断是否全 0，将判断时间从 O(26) 降为 O(1)。
3. **滑动窗口复用状态**：窗口滑动时仅更新左右边界字符的频次，无需重新统计整个窗口，保证线性时间。

## 七、总结
本题最优解法的核心是**滑动窗口 + 数组计数 + 差异值优化**，完美平衡了时间和空间效率：
- 时间复杂度 O(n)：仅需遍历 `s` 一次，效率最优。
- 空间复杂度 O(1)：仅用固定大小辅助空间，无额外开销。
- 适用场景：所有需要判断固定长度子串是否为某字符串字母异位词的问题，是面试高频考点。